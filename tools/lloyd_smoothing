#! /usr/bin/env python
# -*- coding: utf-8 -*-
import numpy
from matplotlib import pyplot as plt
import pyfvm


def _flip_edges(mesh):
    '''Flips the edges which have negative covolume.
    '''
    is_flip_edge = (mesh.ce_ratios < 0.0)
    is_flip_edge_per_cell = is_flip_edge[mesh.cells['edges']]

    # can only handle the case where each cell has at most one edge to flip
    count = numpy.sum(is_flip_edge_per_cell, axis=1)
    assert all(count <= 1)

    # add new cells
    edge_cells = mesh.compute_edge_cells()
    flip_edges = numpy.where(is_flip_edge)[0]
    new_cells = numpy.empty((len(flip_edges), 2, 3), dtype=int)
    for k, flip_edge in enumerate(flip_edges):
        adj_cells = edge_cells[flip_edge]
        assert len(adj_cells) == 2
        # The local edge ids are opposite of the local vertex with the same id.
        cell0_local_edge_id = numpy.where(
            is_flip_edge_per_cell[adj_cells[0]]
            )[0]
        cell1_local_edge_id = numpy.where(
            is_flip_edge_per_cell[adj_cells[1]]
            )[0]

        #     0
        #     /\
        #    /  \
        #   / 0  \
        # 2/______\3
        #  \      /
        #   \  1 /
        #    \  /
        #     \/
        #      1
        verts = [
            mesh.cells['nodes'][adj_cells[0], cell0_local_edge_id],
            mesh.cells['nodes'][adj_cells[1], cell1_local_edge_id],
            mesh.cells['nodes'][adj_cells[0], (cell0_local_edge_id + 1) % 3],
            mesh.cells['nodes'][adj_cells[0], (cell0_local_edge_id + 2) % 3]
            ]
        new_cells[k, 0] = [verts[0], verts[1], verts[2]]
        new_cells[k, 1] = [verts[0], verts[1], verts[3]]

    # find cells that can stay cells
    is_good_cell = numpy.all(
            numpy.logical_not(is_flip_edge_per_cell),
            axis=1
            )

    cells = numpy.r_[
        mesh.cells['nodes'][is_good_cell],
        new_cells[:, 0, :],
        new_cells[:, 1, :]
        ]

    return mesh.node_coords, cells


def smoothing():
    mesh, _, _, _ = pyfvm.reader.read('circle000.vtu')
    # mesh, _, _, _ = pyfvm.reader.read('pacman000.vtu')

    # points = numpy.array([
    #     [0.0, 0.0, 0.0],
    #     [1.0, 0.0, 0.0],
    #     [1.0, 1.0, 0.0],
    #     [0.0, 1.0, 0.0],
    #     [0.1, 0.5, 0.0]
    #     ])
    # cells = numpy.array([
    #     [0, 1, 4],
    #     [1, 2, 4],
    #     [2, 3, 4],
    #     [3, 0, 4]
    #     ])
    # mesh = pyfvm.mesh_tri.MeshTri(points, cells)

    # 2D mesh
    assert all(mesh.node_coords[:, 2] == 0.0)

    while any(mesh.ce_ratios < 0.0):
        points, cells = _flip_edges(mesh)
        mesh = pyfvm.mesh_tri.MeshTri(points, cells)

    # mesh.show()
    # plt.show()

    boundary_verts = mesh.get_vertices('boundary')

    tol = 1.0e-5
    max_move = tol + 1

    k = 0
    while max_move > tol:
        new_points = mesh.centroids
        new_points[boundary_verts] = mesh.node_coords[boundary_verts]
        diff = new_points - mesh.node_coords
        # maximum move
        max_move = numpy.sqrt(numpy.max(numpy.sum(diff*diff, axis=1)))
        print('%d %.15e' % (k, max_move))
        mesh = pyfvm.mesh_tri.MeshTri(new_points, mesh.cells['nodes'])
        # mesh.show()
        # plt.show()
        while any(mesh.ce_ratios < 0.0):
            points, cells = _flip_edges(mesh)
            mesh = pyfvm.mesh_tri.MeshTri(points, cells)
            # mesh.show()
            # plt.show()
        # assert all(mesh.ce_ratios >= 0.0)
        mesh.write('circle%03d.vtu' % (k+1))
        k += 1

    return


if __name__ == '__main__':
    smoothing()
