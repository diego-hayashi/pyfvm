#! /usr/bin/env python
# -*- coding: utf-8 -*-
import argparse
import numpy
from matplotlib import pyplot as plt
import pyfvm


def _flip_edges(mesh):
    '''Flips the edges which have negative covolume.
    '''
    is_flip_edge = (mesh.ce_ratios < 0.0)
    is_flip_edge_per_cell = is_flip_edge[mesh.cells['edges']]

    # can only handle the case where each cell has at most one edge to flip
    count = numpy.sum(is_flip_edge_per_cell, axis=1)
    assert all(count <= 1)

    # add new cells
    edge_cells = mesh.compute_edge_cells()
    flip_edges = numpy.where(is_flip_edge)[0]
    new_cells = numpy.empty((len(flip_edges), 2, 3), dtype=int)
    for k, flip_edge in enumerate(flip_edges):
        adj_cells = edge_cells[flip_edge]
        assert len(adj_cells) == 2
        # The local edge ids are opposite of the local vertex with the same id.
        cell0_local_edge_id = numpy.where(
            is_flip_edge_per_cell[adj_cells[0]]
            )[0]
        cell1_local_edge_id = numpy.where(
            is_flip_edge_per_cell[adj_cells[1]]
            )[0]

        #     0
        #     /\
        #    /  \
        #   / 0  \
        # 2/______\3
        #  \      /
        #   \  1 /
        #    \  /
        #     \/
        #      1
        verts = [
            mesh.cells['nodes'][adj_cells[0], cell0_local_edge_id],
            mesh.cells['nodes'][adj_cells[1], cell1_local_edge_id],
            mesh.cells['nodes'][adj_cells[0], (cell0_local_edge_id + 1) % 3],
            mesh.cells['nodes'][adj_cells[0], (cell0_local_edge_id + 2) % 3]
            ]
        new_cells[k, 0] = [verts[0], verts[1], verts[2]]
        new_cells[k, 1] = [verts[0], verts[1], verts[3]]

    # find cells that can stay cells
    is_good_cell = numpy.all(
            numpy.logical_not(is_flip_edge_per_cell),
            axis=1
            )

    cells = numpy.r_[
        mesh.cells['nodes'][is_good_cell],
        new_cells[:, 0, :],
        new_cells[:, 1, :]
        ]

    return mesh.node_coords, cells


def lloyd_smoothing(mesh, tol, verbose=True):
    # 2D mesh
    assert all(mesh.node_coords[:, 2] == 0.0)

    # If any of the covolume-edge length ratios is negative, it must be on the
    # interior. If we flip the edge, it should be positive.
    if any(mesh.ce_ratios < 0.0):
        points, cells = _flip_edges(mesh)
        mesh = pyfvm.mesh_tri.MeshTri(points, cells)
    assert all(mesh.ce_ratios >= 0.0)

    boundary_verts = mesh.get_vertices('boundary')

    tol = 1.0e-5
    max_move = tol + 1

    k = 0
    while max_move > tol:
        k += 1

        # move interior points into centroids
        new_points = mesh.centroids
        new_points[boundary_verts] = mesh.node_coords[boundary_verts]
        diff = new_points - mesh.node_coords
        max_move = numpy.sqrt(numpy.max(numpy.sum(diff*diff, axis=1)))

        if verbose:
            print('step: %d,  maximum move: %.15e' % (k, max_move))

        # create new mesh and flip edges if necessary
        mesh = pyfvm.mesh_tri.MeshTri(new_points, mesh.cells['nodes'])
        if any(mesh.ce_ratios < 0.0):
            points, cells = _flip_edges(mesh)
            mesh = pyfvm.mesh_tri.MeshTri(points, cells)
        assert all(mesh.ce_ratios >= 0.0)

        # mesh.write('circle%04d.vtu' % (k+1))

    return mesh


def _parse_input_arguments():
    parser = argparse.ArgumentParser(
        description='Perform Lloyd smoothing on a 2D mesh.'
        )

    parser.add_argument(
        'input',
        metavar='INPUT',
        type=str,
        help='Input file'
        )

    parser.add_argument(
        'output',
        metavar='OUTPUT',
        type=str,
        help='Output file'
        )

    parser.add_argument(
        '--tolerance', '-t',
        metavar='TOL',
        type=float,
        required=True,
        help='convergence criterium (maximum move)'
        )

    parser.add_argument(
            '--verbose', '-v',
            dest='verbose',
            action='store_true',
            default=False
            )

    return parser.parse_args()


if __name__ == '__main__':
    args = _parse_input_arguments()
    mesh, _, _, _ = pyfvm.reader.read(args.input)
    out_mesh = lloyd_smoothing(mesh, args.tolerance, verbose=args.verbose)
    out_mesh.write(args.output)
